scalar UUID

schema {
  query: Query
  mutation: Mutation
}

type Query {
  info: String!
  user: User
  module(uuid: UUID!): Module
  test(uuid: UUID!): Test
  lesson(uuid: UUID!): Lesson
}

type Mutation {
  delegateLogin(input: DelegateLogin!): AuthToken
}

type PageInfo {
  total: Int! # Number of pages after this one
  offset: Int! # The offset of this page from the start
  limit: Int! # The max shown per page
  given: Int! # Number of items given
}

input Page {
  offset: Int
  limit: Int
}

interface PaginatedQuery {
  pageInfo: PageInfo
}

input OrderBy {
  ascending: Boolean
  field: String!
}

input DelegateLogin {
  TTC_ID: String!
  password: String!
  noResp: Boolean
}

type Company {
  approved: Boolean
  uuid: UUID!
  createdAt: String
  name: String!
  address: Address!
}

type Address {
  addressLine1: String!
  addressLine2: String!
  county: String!
  postCode: String!
  country: String!
}

type Course {
  id: Int!
  type: CourseType!
  name: String!
  backgroundCheck: Boolean
  price: Float!
  color: String
  excerpt: String
  introduction: String
  howToComplete: String
  hoursToComplete: Float
  whatYouLearn: [String!]
  requirements: [String!]
  specificTerms: String
  category: Category
  allowedToBuy: Boolean
  syllabus: [SyllabusItem!]
  bannerImageURL: String
}

type CoursePage implements PaginatedQuery {
  edges: [Course]
  pageInfo: PageInfo
}

enum UserType {
  manager
  individual
  delegate
}

# User is a thin type that collates information about the manager, delegate
# and individual user types. Some fields are not going to be available depending
# on the type of user you are requesting data for.
type User {
  type: UserType!
  email: String
  firstName: String!
  lastName: String!
  telephone: String
  jobTitle: String
  lastLogin: String!
  company: Company
  profileImageUrl: String
  activity(page: Page): ActivityPage
  myCourses: [MyCourse!]
  myActiveCourse(id: Int!): MyCourse # Get my course from courseID
  # certificates
  # address: Address
}

enum ActivityType {
  newCourse
  activated
  completedCourse
  failedCourse
}

type ActivityPage implements PaginatedQuery {
  edges: [Activity]
  pageInfo: PageInfo
}

type Activity {
  uuid: UUID!
  type: ActivityType!
  createdAt: String!
  course: Course
}

enum CourseStatus {
  passed
  failed
  incomplete
}

# # A course currently being taken by a user
type MyCourse {
  status: CourseStatus!
  course: Course!
  minutesTracked: Float!
  enrolledAt: String!
}

type AuthToken {
  token: String!
}

enum AccessType {
  restricted
  open
}

enum StructureElement {
  module
  test
  lesson
}

enum CourseType {
  online
  classroom
}

interface SyllabusItem {
  name: String!
  uuid: UUID!
  type: StructureElement!
  complete: Boolean # Only shown for courseTaker users (delegates and individuals)
}

type Lesson implements SyllabusItem {
  name: String!
  uuid: UUID!
  complete: Boolean
  mp3URL: String
  text: String!
}

type Module implements SyllabusItem {
  uuid: UUID!
  name: String!
  type: StructureElement!
  bannerImageURL: String
  description: String!
  transcript: String!
  voiceoverURL: String
  video: Video
  syllabus: [SyllabusItem!]
  complete: Boolean
}

type Test implements SyllabusItem {
  name: String!
  uuid: UUID!
  type: StructureElement!
  complete: Boolean
  attemptsAllowed: Int
  passPercentage: Float
  questionsToAnswer: Int
  randomiseAnswers: Boolean
  questions: [Question!]
}

type Question {
  uuid: UUID!
  text: String!
  questionType: QuestionType!
}

enum QuestionType {
  SINGLE_CHOICE
}

type Category {
  uuid: UUID
  name: String!
  color: String!
}

enum VideoType {
  WISTIA
}

type Video {
  type: VideoType!
  url: String!
}
